{"version":3,"sources":["taoensso/tempura/impl.cljc"],"mappings":"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","names":["taoensso.tempura.impl/str->?arg-idx","s","G__68776","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","taoensso.tempura.impl/re-clojure-arg","taoensso.tempura.impl/str->split-args","e","taoensso.truss.impl/-dummy-error","e68777","js/Error","taoensso.truss.impl/-invar-violation!","cljs.core/not","and__4120__auto__","taoensso.encore/str-contains?","cljs.core/re-find","uuid-esc","taoensso.encore.uuid_str.cljs$core$IFn$_invoke$arity$0","taoensso.encore/str-replace","?arg-seq","cljs.core/re-seq","cljs.core/empty?","arg-idxs","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","splits","clojure.string.split.cljs$core$IFn$_invoke$arity$2","_","z","e68779","taoensso.truss.impl/WrappedError","taoensso.truss.impl/some?","e68780","arg-idxs-count","splits-count","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","taoensso.encore/vinterleave-all","var_args","G__68783","taoensso.tempura.impl/str->vargs-fn","taoensso.tempura.impl.str__GT_vargs_fn.cljs$core$IFn$_invoke$arity$2","argval-fn","e68784","parts","or__4131__auto__","taoensso.encore/undefined->nil","cljs.core/count","vec__68785","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","p1","vargs","cljs.core/integer?","G__68789","cljs.core.get.cljs$core$IFn$_invoke$arity$2","sb","taoensso.encore.str_builder.cljs$core$IFn$_invoke$arity$0","cljs.core/run!","p","taoensso.encore.sb_append.cljs$core$IFn$_invoke$arity$2","G__68791","taoensso.tempura.impl/mapv-nested","f","v","in","cljs.core/vector?","f1","taoensso.tempura.impl/reducev-nested","rf","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","acc","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","rf1","G__68795","taoensso.tempura.impl/node-paths","m","taoensso.tempura.impl.node_paths.cljs$core$IFn$_invoke$arity$3","cljs.core/associative?","node-pred","basis","cljs.core/reduce-kv","k","cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic","paths-from-basis","cljs.core.into.cljs$core$IFn$_invoke$arity$2","G__68798","taoensso.tempura.impl/vec->vargs-fn","taoensso.tempura.impl.vec__GT_vargs_fn.cljs$core$IFn$_invoke$arity$2","e68799","node-paths","taoensso.tempura.impl.node_paths.cljs$core$IFn$_invoke$arity$1","idxs->arg-idxs","el","cljs.core/peek","cljs.core/Symbol","temp__5733__auto__","idx","cljs.core/name","cljs.core/assoc-in","cljs.core/pop","cljs.core/identity","cljs.core/map?","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","G__68800","taoensso.tempura.impl/vec-explode-args-in-strs","e68801","cljs.core.symbol.cljs$core$IFn$_invoke$arity$1","taoensso.tempura.impl/str->split-styles","e68807","cljs.core/deref","matches_","cljs.core/volatile!","replace-matches","regex","tag","p__68808","vec__68810","content","uuid","uuid-esc*","uuid-esc_","uuid-esc-tilde","matches","ordered-match-ks","p1__68805#","cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2","taoensso.encore.str__QMARK_index.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","ordered-match-vs","p1__68806#","cljs.core/re-pattern","clojure.string.join.cljs$core$IFn$_invoke$arity$2","taoensso.tempura.impl/vec->vtag","e68814","vec__68816","v1","cljs.core/Keyword","G__68820","taoensso.tempura.impl/vec-explode-styles-in-strs","taoensso.tempura.impl.vec_explode_styles_in_strs.cljs$core$IFn$_invoke$arity$2","str-splitter","e68821","taoensso.tempura.impl/escape-html","taoensso.tempura.impl/vec-escape-html-in-strs","e68826","x","taoensso.tempura.impl/expand-locales","expand-locale","taoensso.encore/memoize_","locale","clojure.string/lower-case","p1__68831#","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","cljs.core.take_while.cljs$core$IFn$_invoke$arity$2","cljs.core/iterate","cljs.core/butlast","expand-locales*","locales","G__68832","vec__68833","p__68836","vec__68837","seen","lvars","lbase","expand-locales*-cached","cache?","taoensso.tempura.impl/load-resource","rname","taoensso.tempura.impl/compile-dictionary","preprocess","dict","path","taoensso.encore/explode-keyword","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","cljs.core/keyword","io-res","as-paths","vec__68841","normed-locale","taoensso.encore.merge_keywords.cljs$core$IFn$_invoke$arity$1","taoensso.tempura.impl.node_paths.cljs$core$IFn$_invoke$arity$2","compile-dictionary*","taoensso.encore.memoize_STAR_.cljs$core$IFn$_invoke$arity$2","G__68847","compile-dictionary*-cached","taoensso.tempura.impl/vargs","max-idx","p1__68850#","p2__68851#","n1__66315__auto__","n2__66316__auto__","cljs.core.range.cljs$core$IFn$_invoke$arity$2","e68857"],"sourcesContent":["(ns taoensso.tempura.impl\n  \"Private implementation details.\"\n  (:require\n   [clojure.string :as str]\n   #?(:clj  [clojure.test    :as test :refer        [deftest is]])\n   #?(:clj  [taoensso.encore :as enc  :refer        [have have? qb]])\n   #?(:cljs [taoensso.encore :as enc  :refer-macros [have have?]])))\n\n(comment (test/run-tests))\n\n(defn str->?arg-idx [s]\n  (case s\n    ;; % 0 ; No, prefer minimizing alternatives + allows % literal pass through\n    ;; \"%\" (throw (ex-info \"`%` is invalid, please use `%1`\"))\n    \"%0\" (throw (ex-info \"`%0` is invalid, starts at `%1`\" {:s s}))\n    \"%1\" 0 \"%2\" 1, \"%3\" 2, \"%4\" 3, \"%5\" 4, \"%6\" 5, \"%7\" 6, \"%8\" 7, \"%9\" 8,\n    nil))\n\n(def ^:private re-clojure-arg #_#\"%\\d?\" #\"%\\d\")\n\n(defn str->split-args\n  \"Checks string for simple Clojure-style (%d) args and returns a vector of\n  string parts and int arg indexes for later joining.\"\n  [s]\n  (have? string? s)\n  (if-not (and (enc/str-contains? s \"%\") (re-find re-clojure-arg s))\n    [s] ; Optimize common case\n    (let [uuid-esc (enc/uuid-str)\n          s        (enc/str-replace s \"`%\" uuid-esc) ; Protect escaped %'s\n          ?arg-seq (re-seq re-clojure-arg s)]\n\n      (if (empty? ?arg-seq) ; May have had escaped %, etc.\n        [(enc/str-replace s uuid-esc \"%\")]\n        (let [arg-idxs (mapv str->?arg-idx ?arg-seq)\n              splits   (str/split s re-clojure-arg)\n              splits   (mapv (fn [s] (enc/str-replace s uuid-esc \"%\")) splits)\n              _        (have (fn [arg-idxs-count splits-count]\n                               (= arg-idxs-count (- splits-count 1))))]\n          (enc/vinterleave-all splits arg-idxs))))))\n\n(comment\n  (str->split-args \"hello %1, how are %1 %2? %% `% ``%\")\n  (str->split-args \"hello %1\") ; => [\"hello \" 0]\n  (str->split-args \"%1\") ; => [0]\n  )\n\n(defn str->vargs-fn\n  \"Returns a (fn [args-vector]) which replaces simple Clojure-style (%n) args\n  in string with `(str (?argval-fn <corresponding-vector-arg>))`.\n  Optimized for fn runtime, not fn creation.\"\n  ([s] (str->vargs-fn s nil))\n  ([s argval-fn]\n   (have? string? s)\n   (let [parts (str->split-args s)\n         ;; Why the undefined check? Vestigial?\n         argval-fn (or argval-fn #?(:clj identity :cljs enc/undefined->nil))]\n\n     (if (= (count parts) 1) ; Optimize common-case:\n       (let [[p1] parts]\n         (enc/cond!\n           (string?  p1) (fn [vargs] p1)\n           (integer? p1) (fn [vargs] (str (argval-fn (get vargs p1))))))\n\n       (fn [vargs]\n         (let [sb (enc/str-builder)]\n           (run!\n             (fn [p]\n               (if (string? p)\n                 (enc/sb-append sb p)\n                 (enc/sb-append sb (str (argval-fn (get vargs p))))))\n             parts)\n           (str sb)))))))\n\n(comment\n  (str->split-args \"hello %1 %2\")\n  ((str->vargs-fn \"\")            [\"a\" \"b\"]) ; \"\"\n  ((str->vargs-fn \"hello %1 %2\") [\"a\" \"b\"]) ; \"hello a b\"\n  ((str->vargs-fn \"hello\") [\"a\" \"b\"]) ; \"hello\"\n  ((str->vargs-fn \"%1\")    [\"a\" \"b\"]) ; \"a\"\n  ((str->vargs-fn \"%2\")    [\"a\" \"b\"]) ; \"b\"\n  (let [f1 (fn [vargs] (apply format \"hello %s %s\" vargs))\n        f2 (str->vargs-fn \"hello %1 %2\")]\n    (qb 1e5\n      (f1 [\"a1\" \"a2\"])\n      (f2 [\"a1\" \"a2\"]))))\n\n#?(:clj\n   (deftest _str->vargs-fn\n     (is (thrown? Exception (str->vargs-fn nil)))\n     ;; (is (thrown? Exception ((str->vargs-fn \"%\") \"non-vector input\")))\n     (is (= \"hi\"      ((str->vargs-fn \"hi\")         [])))\n     (is (= \"hi\"      ((str->vargs-fn \"hi\")         [\"unused arg\"])))\n     (is (= \"hi %1\"   ((str->vargs-fn \"hi `%1\")     [])))\n     (is (= \"hi a1\"   ((str->vargs-fn \"hi %1\")      [\"a1\"])))\n     (is (= \"hi :a1\"  ((str->vargs-fn \"hi %1\")      [:a1]))) ; `str` called on args\n     (is (= \"hi \"     ((str->vargs-fn \"hi %1\")      [])))    ; insufficient args\n     (is (= \"hi nil\"  ((str->vargs-fn \"hi %1\" #(if (nil? %) \"nil\" %)) []))) ; nil-patch\n     (is (= \"a1, hi\"  ((str->vargs-fn \"%1, hi\") [\"a1\"]))) ; \"\" start with arg\n     (is (= \"hi :1 :2 :1 :3 :1 %1 :1 %3 :11 a:2b%end % %s\"\n           ((str->vargs-fn \"hi %1 %2 %1 %3 %1 `%1 %1 `%3 %11 a%2b`%end % %s\")\n            [:1 :2 :3 :4])))))\n\n(defn- mapv-nested     [f v] (mapv (fn f1 [in] (if (vector? in) (mapv f1 in) (f in))) v))\n(defn- reducev-nested [rf v]\n  (reduce\n    (fn rf1 [acc in]\n      (if (vector? in)\n        (conj acc (reduce rf1 [] in))\n        (rf acc in)))\n    [] v))\n\n(comment (mapv-nested keyword [\"a\" \"b\" [\"c\" \"d\"]]))\n\n#_\n(defn- reduce-kv-nested [rf m]\n  (reduce-kv\n    (fn rf1 [acc k v]\n      (if (map? v)\n        (assoc acc k (reduce-kv rf1 {} v))\n        (rf acc k v)))\n    {} m))\n\n(defn node-paths ; Also in tl-core\n  ([          m      ] (node-paths associative? m nil))\n  ([node-pred m      ] (node-paths node-pred    m nil))\n  ([node-pred m basis]\n   (let [basis (or basis [])]\n     (reduce-kv\n       (fn [acc k v]\n         (if-not (node-pred v)\n           (conj acc (conj basis k v))\n           (let [paths-from-basis (node-paths node-pred v (conj basis k))]\n             (into acc paths-from-basis))))\n       [] m))))\n\n(comment\n  (node-paths associative? {:a1 :A1 :a2 {:b1 :B1 :b2 {:c1 :C1 :c2 :C2}}} [:h])\n  (node-paths [:a1 :a2 [:b1 :b2 [:c1 :c2] :b3] :a3 :a4]))\n\n(defn vec->vargs-fn\n  \"Returns a (fn [args-vector]) which replaces simple Clojure-style (%n) arg\n  elements with `(?argval-fn <corresponding-vector-arg>)`.\n  Optimized for fn runtime, not fn creation.\"\n  ([v] (vec->vargs-fn v nil))\n  ([v argval-fn]\n   (have? vector? v)\n   (let [node-paths (node-paths v)\n         idxs->arg-idxs ; {2 0, 3 {2 1}, 5 {1 {1 0}}}, etc.\n         (reduce\n           (fn [acc in]\n             (let [el (peek in)]\n               (if-not (symbol? el)\n                 acc\n                 (if-let [idx (str->?arg-idx (name el))]\n                   (assoc-in acc (pop in) idx)\n                   acc))))\n           {} node-paths)]\n\n     (if (empty? idxs->arg-idxs)\n       (fn [vargs] v) ; Common case\n       (let [argval-fn (or argval-fn identity)]\n         (fn [vargs]\n           (reduce-kv\n             (fn rf1 [acc k v]\n               (if (map? v)\n                 (assoc acc k (reduce-kv rf1 (get acc k) v))\n                 (assoc acc k (argval-fn (get vargs v)))))\n             v idxs->arg-idxs)))))))\n\n#?(:clj\n   (deftest _vec->vargs-fn\n     (is (thrown? Exception (vec->vargs-fn nil)))\n     ;; (is (thrown? Exception ((vec->vargs-fn ['%1]) \"non vector input\")))\n     (is (= [\"hi\"]      ((vec->vargs-fn [\"hi\"])     [])))\n     (is (= [\"hi\"]      ((vec->vargs-fn [\"hi\"])     [\"unused arg\"])))\n     (is (= [\"hi\" \"a1\"] ((vec->vargs-fn [\"hi\" '%1]) [\"a1\"])))\n     (is (= [\"hi\" :a1]  ((vec->vargs-fn [\"hi\" '%1]) [:a1]))) ; Arb args\n     (is (= [\"hi\" nil]  ((vec->vargs-fn [\"hi\" '%1]) [])))    ; Insufficient args\n     (is (= [\"hi\" [:strong :1] \", \" :1 :2]\n           ((vec->vargs-fn [\"hi\" [:strong '%1] \", \" '%1 '%2]) [:1 :2 :3])))\n     (is (= [\"a1\" \", hi\"] ((vec->vargs-fn ['%1 \", hi\"]) [\"a1\"]))) ; Start with arg\n     (is (= [\"hi\" {:attr \"foo %1\"}] ; Don't touch attrs\n           ((vec->vargs-fn [\"hi\" {:attr \"foo %1\"}]) [\"a1\"])))))\n\n;;;;\n\n(defn vec-explode-args-in-strs [v]\n  (have? vector? v)\n  (reducev-nested\n    (fn [acc in]\n      (if-not (string? in)\n        (conj acc in)\n        (let [parts (str->split-args in)\n              parts (mapv (fn [p] (if (string? p) p (symbol (str \"%\" (inc p)))))\n                      parts)]\n          (into acc parts))))\n    v))\n\n(comment\n  (vec-explode-args-in-strs\n    [:a [:b [:c \"hi %1\" \"boo\"] \"hi %1 %1\" [:strong \"My name is %3\"] \"%1\"]]))\n\n;;;;\n\n(defn str->split-styles [s]\n  (have? string? s)\n  (let [matches_ (volatile! {})\n        replace-matches\n        (fn [s regex tag]\n          (enc/str-replace s regex\n            (fn [[_ _ content]]\n              (let [uuid (enc/uuid-str)]\n                (vswap! matches_ assoc uuid [tag content])\n                uuid))))\n\n        uuid-esc*      (enc/uuid-str)\n        uuid-esc_      (enc/uuid-str)\n        uuid-esc-tilde (enc/uuid-str)\n\n        ;; TODO Reddit also escapes everything between \\* and \\*,\n        ;; Ref. https://www.reddit.com/wiki/commenting. Duplicate that or\n        ;; something like it? Probably overkill for our (mostly 1-line) needs.\n\n        s (enc/str-replace s \"`*\" uuid-esc*)\n        s (enc/str-replace s \"`_\" uuid-esc_)\n        s (enc/str-replace s \"`~\" uuid-esc-tilde)\n\n        ;;; Intentionally _very_ simple/conservative styling capabilities\n        s (replace-matches s #\"(\\*\\*)([^\\*\\r\\n]+)\\1\" :strong)\n        s (replace-matches s   #\"(__)([^_\\r\\n]+)\\1\"  :b)\n        s (replace-matches s   #\"(\\*)([^\\*\\r\\n]+)\\1\" :em)\n        s (replace-matches s    #\"(_)([^_\\r\\n]+)\\1\"  :i)\n\n        ;; This common enough to be worthwhile?\n        s (replace-matches s   #\"(~~)([^~\\r\\n]+)\\1\"  :s) ; Strikeout\n\n        s (enc/str-replace s uuid-esc*      \"*\")\n        s (enc/str-replace s uuid-esc_      \"_\")\n        s (enc/str-replace s uuid-esc-tilde \"~\")\n\n        matches @matches_]\n\n    (if (empty? matches)\n      [s]\n      (let [ordered-match-ks (sort-by #(enc/str-?index s %) (keys matches))\n            ordered-match-vs (mapv #(get matches %) ordered-match-ks)\n            splits (str/split s (re-pattern (str/join \"|\" ordered-match-ks)))]\n        (enc/vinterleave-all splits ordered-match-vs)))))\n\n(comment (str->split-styles \"_hello_ **there** this is a _test_ `*yo`*\"))\n\n(defn vec->vtag\n  \"[\\\"foo\\\"] -> [:span \\\"foo\\\"] as a convenience.\"\n  [v]\n  (have? vector? v)\n  (let [[v1] v]\n    (if-not (keyword? v1)\n      (into [:span] v)\n      v)))\n\n(comment\n  (vec->vtag [:div.special \"foo\"]) ; Allow control of tag type\n  (vec->vtag [\"foo\"]) ; But default to :span\n  (vec->vtag []))\n\n(defn vec-explode-styles-in-strs\n  ([v] (vec-explode-styles-in-strs v str->split-styles))\n  ([v str-splitter]\n   (have? vector? v)\n   (reducev-nested\n     (fn [acc in]\n       (if-not (string? in)\n         (conj acc in)\n         (into acc (str-splitter in))))\n     v)))\n\n(comment (vec-explode-styles-in-strs [:a \"hello there **this** is a test\"]))\n\n;;;;\n\n(defn escape-html ; Modified from `tl-core/html-esc`\n  [s]\n  (-> s\n    (enc/str-replace    \"&\"  \"&amp;\") ; First!\n    (enc/str-replace    \"<\"  \"&lt;\")\n    (enc/str-replace    \">\"  \"&gt;\")\n    ;; (enc/str-replace \"'\"  \"&#39;\") ; NOT &apos;\n    (enc/str-replace    \"\\\"\" \"&quot;\")))\n\n(comment\n  (html-escape \"Hello, x>y & the cat's hat's fuzzy. <boo> \\\"Hello there\\\"\"))\n\n(defn vec-escape-html-in-strs [v]\n  (have? vector? v)\n  (mapv-nested (fn [x] (if (string? x) (escape-html x) x)) v))\n\n(comment (vec-escape-html-in-strs [:div \"Hello there \" [:strong \"& goodbye\"]]))\n\n;;;;\n\n(def expand-locales\n\n  ;; TODO Note that this fallback preference approach might not be\n  ;; sophisticated enough for use with BCP 47, etc. -\n  ;; Ref. https://github.com/ptaoussanis/tower/issues/65\n  ;;\n  ;; Punting on the issue for now; we can always swap out the fallback\n  ;; strategy later. Indeed might not be necessary if consumers can provide\n  ;; an appropriately prepared input for this fn.\n\n  (let [expand-locale\n        (enc/memoize_\n          (fn [locale]\n            (let [parts (str/split (str/lower-case (name locale)) #\"[_-]\")]\n              (mapv #(keyword (str/join \"-\" %))\n                (take-while identity (iterate butlast parts))))))\n\n        expand-locales*\n        (fn [locales]\n          (if (= (count locales) 1)\n            [(expand-locale (get locales 0))]\n            (let [[acc _]\n                  (reduce\n                    (fn [[acc seen] in]\n                      (let [lvars (expand-locale in)\n                            lbase (peek lvars)]\n                        (if (seen lbase)\n                          [acc seen]\n                          [(conj acc lvars) (conj seen lbase)])))\n                    [[] #{}]\n                    locales)]\n              acc)))\n\n        expand-locales*-cached (enc/memoize_ expand-locales*)]\n\n    ;; Inputs are combinatorial, so can't cache by default:\n    (fn [cache? locales]\n      (if cache?\n        (expand-locales*-cached locales)\n        (expand-locales*        locales)))))\n\n(comment\n  (qb 1e5 ; [28.12 159.55]\n    (expand-locales nil [:en-GB-var1])\n    (expand-locales nil [:en-US-var1 :fr-FR :fr :en-GD :DE-de])))\n\n#?(:clj\n   (deftest _expand-locales\n     (is (= [[:en-us-var1 :en-us :en] [:fr-fr :fr] [:de-de :de]]\n           (expand-locales nil [:en-us-var1 :fr-fr :fr :en-gd :de-de])))\n     (is (= [[:en] [:fr-fr :fr] [:de-de :de]] ; Stop :en-* after base :en\n           (expand-locales nil [:en :en-us-var1 :fr-fr :fr :en-gd :de-de])))\n     (is (= [[:en-us :en] [:fr-fr :fr]]    ; Never change langs before vars\n           (expand-locales nil [:en-us :fr-fr :en])))))\n\n#?(:clj (def ^:private cached-read-edn (enc/memoize_ enc/read-edn)))\n(defn load-resource [rname]\n  #?(:clj\n     (if-let [edn (enc/slurp-file-resource rname)]\n       (try\n         (cached-read-edn edn) ; Ref transparent\n         (catch Exception e\n           (throw\n             (ex-info \"Failed to load dictionary resource\"\n               {:rname rname} e))))\n       ;; nil ; Silent failure, lean on :missing\n       (throw\n         (ex-info \"Failed to load dictionary resource (not found)\"\n           {:rname rname})))\n\n     :cljs\n     (throw\n       (ex-info \"Runtime resource loading not possible for cljs dictionaries. See `tempura/load-resource-at-compile-time` as an alternative.\"\n         {:rname rname}))))\n\n(comment (load-resource \"foo.edn\"))\n\n(def compile-dictionary\n  (let [preprocess ; For pointers and slurps, etc.\n        (fn [dict]\n          (reduce-kv\n            (fn rf1 [acc k v]\n              (cond\n                (keyword? v) ; Pointer\n                (let [path (enc/explode-keyword v)]\n                  (assoc acc k (get-in dict (mapv keyword path))))\n\n                (map? v)\n                (if-let [io-res (:__load-resource v)]\n                  (assoc acc k (load-resource io-res))\n                  (assoc acc k (reduce-kv rf1 {} v)))\n\n                :else (assoc acc k v)))\n            {} dict))\n\n        as-paths ; For locale normalization, lookup speed, etc.\n        (enc/memoize_ ; Ref transparent\n          (fn [dict]\n            (reduce\n              (fn [acc in]\n                (let [[locale] in\n                      normed-locale (str/lower-case (name locale))\n                      in (assoc in 0 normed-locale)]\n                  (assoc acc (enc/merge-keywords (pop in)) (peek in))))\n              {} (node-paths map? dict))))\n\n        compile-dictionary*\n        (enc/memoize* 1000 ; Minor caching to help blunt impact on dev benchmarks\n          (fn [dict] (-> dict preprocess preprocess as-paths)))\n\n        compile-dictionary*-cached (enc/memoize_ compile-dictionary*)]\n\n    ;; We may want resource reloads in dev-mode, so can't cache by default:\n    (fn [cache? dict]\n      (if cache?\n        (compile-dictionary*-cached dict)\n        (compile-dictionary*        dict)))))\n\n(comment\n  (qb 1e4\n    (compile-dictionary nil\n      {:en-GB\n       {:example {:foo \"foo\"\n                  :bar \"bar\"\n                  :baz :en.example/bar}\n        :example-copy :en/example\n        :missing \"hi\"\n        :import-example\n        {:__load-resource \"resources/i18n.clj\"}}})))\n\n(defn vargs [x]\n  (if (map? x)\n    (let [^long max-idx (reduce #(enc/max* ^long %1 ^long %2) 0 (keys x))]\n      (assert (nil? (get x 0)) \"All arg map keys must be +ive non-zero ints\")\n      (mapv (fn [idx] (get x idx)) (range 1 (inc max-idx))))\n    (have vector? x)))\n\n(comment (qb 1e4 (vargs {1 :a 2 :b 3 :c 5 :d})))\n"]}